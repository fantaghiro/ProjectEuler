<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Problem 4</title>
	<link rel="stylesheet" href="res/style.css">
	<link rel="stylesheet" href="res/prism.css">
	<script src="res/prism.js"></script>
</head>
<body>
	<h1>Largest palindrome product</h1>
	<div id="wrap">
		<h2>Problem 4</h2>
		<div class="problem">
			<p>A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.</p>
			<p>Find the largest palindrome made from the product of two 3-digit numbers.</p>
			<hr>
			<p>“回文数”（也可以成为对称数）是指各位上的数字正序逆序，数值不变的数。由两个两位数相乘得到的最大回文数是 9009 = 91 × 99。</p>
			<p>请找出由两个三位数相乘可以得到的最大回文数。</p>
		</div>
		<h2>Solution 1</h2>
		<pre><code class="language-javascript">
//这种算法效率极为低下
var result = null;
var resultArr = [];
for(var l=9; l>0; l--){
	for(var m=9; m>=0; m--){
		for(var n=9; n>=0; n--){
			for(x=9; x>0; x--){
				for(y=9; y>=0; y--){
					for(z=9; z>=0; z--){
						result = '' + (l*100+m*10+n)*(x*100+y*10+z);
						var arr = result.split('');
						if(arr[0] == arr[5] && arr[1] == arr[4] && arr[2] == arr[3]){
							resultArr.push(result);
						}
					}
				}
			}
		}
	}
}
resultArr.sort(function(a,b){return b-a});
console.log(resultArr);
		</code></pre>
		<h2>Solution 2</h2>
		<pre><code class="language-javascript">
var a = 0;
var b = 0;
var c = 0;
var largestPalindrome = 0;
function reverse(num){
	var reversed = 0
	while(num > 0){
		reversed = reversed * 10 + num%10;
		num = Math.floor(num / 10);
	}
	return reversed;
}
function isPalindrome(num){
	return num == reverse(num);
}

a = 999;
while(a >= 100){
	b = 999;
	while(b >= 100) {
		c = a * b;
		if(isPalindrome(c) && c > largestPalindrome){
			largestPalindrome = c;
		}
		b--;
	}
	a--;
}

console.log(largestPalindrome);		
		</code></pre>
		<h2>Solution 3</h2>
		<pre><code class="language-javascript">
var a = 0;
var b = 0;
var c = 0;
var largestPalindrome = 0;
function reverse(num){
	var reversed = 0
	while(num > 0){
		reversed = reversed * 10 + num%10;
		num = Math.floor(num / 10);
	}
	return reversed;
}
function isPalindrome(num){
	return num == reverse(num);
}

a = 999;
while(a >= 100){
	b = a; //在上一个算法中，每一个乘机都算了两遍：如a = 236, b = 135和a = 135, b = 236，为了避免重复计算，这里可以设置为b = a; 使b一直小于等于a，同样可以获得所有乘机
	while(b >= 100) {
		c = a * b;
		if(isPalindrome(c) && c > largestPalindrome){
			largestPalindrome = c;
		}
		b--;
	}
	a--;
}

console.log(largestPalindrome);		
		</code></pre>
		<h2>Solution 4</h2>
		<pre><code class="language-javascript">
var a = 0;
var b = 0;
var c = 0;
var largestPalindrome = 0;
function reverse(num){
	var reversed = 0
	while(num > 0){
		reversed = reversed * 10 + num%10;
		num = Math.floor(num / 10);
	}
	return reversed;
}
function isPalindrome(num){
	return num == reverse(num);
}

a = 999;
while(a >= 100){
	b = 999;
	while(b >= a) {
		c = a * b;
		if(c &lt;= largestPalindrome){
			break;
		}

		if(isPalindrome(c)){
			largestPalindrome = c;
		}
		b--;
	}
	a--;
}

console.log(largestPalindrome);	
		</code></pre>
		<h2>Solution 5</h2>
		<pre><code class="language-javascript">
var a = 0;
var b = 0;
var c = 0;
var largestPalindrome = 0;
function reverse(num){
	var reversed = 0
	while(num > 0){
		reversed = reversed * 10 + num%10;
		num = Math.floor(num / 10);
	}
	return reversed;
}
function isPalindrome(num){
	return num == reverse(num);
}

/*p = 100000x + 10000y + 1000z + 100z + 10y + x
p = 100001x + 10010y + 1100z
p = 11(9091x + 910y + 100z) */

//从上述推导看来，p一定能被11整除，因此a、b两数里面，至少有一个能被11整除

a = 999;
while(a >= 100){
	if (a%11 == 0){
		b = 999;
		db = 1;
	} else {
		b = 990; //小于等于999的最大能被11整除的数是990
		db = 11;
	}
	while(b >= a) {
		c = a * b;
		if(c &lt;= largestPalindrome){
			break;
		}

		if(isPalindrome(c)){
			largestPalindrome = c;
		}
		b = b - db;
	}
	a = a - 1;
}

console.log(largestPalindrome);
		</code></pre>
		<h2>Solution 6</h2>
		<pre><code class="language-javascript">
//临时变量
var a,b;
//最大对称数
var maxPalindrome = 0;
//结果：两个三位数
var x,y;
//判断是否对称数
function isPalindrome(num){
	var p=num;
	var n=0;
	while(p>0){
		n=n*10+p%10;
		p=Math.floor(p/10);
	}
	return num==n;
}
//先找符合要求的6位对称数
a=990;
while(a>=110){
	var c;
	var b_min=Math.ceil(100001/a); //100001是最小的一个六位数对称数
	b=999;
	while(b>=b_min) {
		if(b%11!=0){
			c=a*b;
			//var str = 'a: ' + a + '; b: ' + b;
			//console.log(str);
			if(c&lt;=maxPalindrome){
				break;
			}
			if(isPalindrome(c)){
				maxPalindrome=c;
				x=a;
				y=b;
			}
		}
		b--;
	}
	a-=11;
}
//符合要求的6位对称数没有，开始找符合要求的5位对称数
if(maxPalindrome==0){
	a=999;
	while(a>=100){
		var b_max=Math.floor(99999/a);
		b=a; 
		while(b>=100 && b&lt;=b_max) {
			c=a*b;
			if(c&lt;=maxPalindrome){
				break;
			}
			if(isPalindrome(c)){
				maxPalindrome=c;
				x=a;
				y=b;
			}
			b--;
		}
		a--;
	}
}
//输出结果
if(maxPalindrome!=0){
	var str = '两个三位数相乘得到的最大对称数为：' + maxPalindrome + '\n' + '两数分别为' + x + '和' + y; 
	console.log(str);
} else {
	console.log('两个三位数相乘不存在对称数乘积。');
}		
		</code></pre>
	</div>
</body>
</html>