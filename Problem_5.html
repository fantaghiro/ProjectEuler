<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Problem 5</title>
	<link rel="stylesheet" href="res/style.css">
	<link rel="stylesheet" href="res/prism.css">
	<script src="res/prism.js"></script>
</head>
<body>
	<h1>Smallest multiple</h1>
	<div id="wrap">
		<h2>Problem 5</h2>
		<div class="problem">
			<p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.</p>
			<p>What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?</p>
			<hr>
			<p>2520是能够被1到10这十个数字整除的最小公倍数。</p>
			<p>请问能够被1至20这二十个数字除尽的最小正公倍数是多少？</p>
		</div>
		<h2>Solution 1</h2>
		<pre><code class="language-javascript">
//最基本和直接的思路
var n = 20;
var i;

function divisible(num){ //判断某数是否能够整除1-20
	for(var i=1; i&lt;=20; i++){
		if(num%i != 0) {
			return false;
		}
	}
	return true;
}

while(n >= 20){
	if(divisible(n)){
		console.log(n);
		break;
	} else {
		n++;
	}
}
		</code></pre>
		<h2>Solution 2</h2>
		<pre><code class="language-javascript">
function largestDiv(a, b){ //用辗转相除法求两个数的最大公因数
	if(a % b == 0){
		return b;
	} else if(a > b){
		var c = a % b;
		a = b;
		b = c;
		return largestDiv(a, b);
	} else if(a &lt; b){
		return largestDiv(b, a);
	}
}

function smallestMul(a, b){ //两数的乘积等于两数最大公约数和最小公倍数的乘积，通过此规律求最小公倍数
	return a * b / largestDiv(a, b);
}

// 通过迭代方式求1至20的最小公倍数
// 1至3要求1、2和1、2的公倍数与3的公倍数，那么1至20就要迭代19次
function toSolve(){
	var re = smallestMul(1, 2);
	for(var i=1; i&lt;=18; i++){
		re = smallestMul(re, i+2);
	}
	return re;
}

console.log(toSolve());		
		</code></pre>
		<h2>Solution 3</h2>
		<pre><code class="language-javascript">
var arr = []; //用于存放20以下的质数
var result = 1; //用于存放答案
function isPrime(num){ //判断是否为素数
	for(var i=2; i&lt;=Math.ceil(num/2);i++){
		if(num%i == 0){
			return false;
		}
	}
	return true;
}

for(var i=2; i&lt;=20; i++){
	if(isPrime(i)){
		arr.push(i);
	}
} //获得小于等于20的质数组成的数组

//2^4=16，2^5=32，因此1~20的最小公倍数肯定有四个2因子，而不能超过4个。同理3^2=9，3^3=27，那么1~20的最小公倍数肯定有两个3因子。总结下来 质数Z^n次方=K，K要小于20。等式两边同取log得到：log(Z^n)=log(K) => n*log(Z)=logK => n=log(K)/log(Z) = Math.floor(log(20)/log(Z))。
//另外，根据上式也可以得到：如果质数Z大于20的平方根的话，那么该质数在1~20的最小公倍数的因子里面只能出现1次。

for(var i=0; i&lt;arr.length; i++){
	if(arr[i]&lt;Math.sqrt(20)){
		n = Math.floor(Math.log(20)/Math.log(arr[i]))
		result *= Math.pow(arr[i], n);
	} else {
		result *= arr[i];
	}
}

console.log(result);		
		</code></pre>
		<h2>Solution 4</h2>
		<pre><code class="language-javascript">
function findQ(n){
	var Q=1;
	var P=new Array();
	var i,j;
	for(i=2;i&lt;=n;i++){
    	P[i] = i;
 	}
 	for(i=2;i&lt;=n;i++){
    	if(P[i]){
    		for(j=i;j*i&lt;=n;j++){
            	P[i*j]=0;
          	}
    	}
	}
	for(i=2;i&lt;=n;i++) {
    	if(P[i]) {
    		if(P[i]&lt;Math.sqrt(n)){
				Q*= Math.pow(P[i], Math.floor(Math.log(n)/Math.log(P[i])));
			} else {
				Q*=P[i];
			}
     	} 
    }
    return Q;
}			
//输出结果
console.log(findQ(20));		
		</code></pre>
		<h2>Solution 5</h2>
		<pre><code class="language-javascript">
function findQ(n){
	var Q=1;
	var P=new Array();
	var i,j;
	for(i=2;i&lt;=n;i++){
    	P[i] = i;
 	}
 	for(i=2;i&lt;n;i++){  
		for(j=i+1;j&lt;=n;j++){  
    		if(P[j]%P[i]==0){
        		P[j]=P[j]/P[i];
    		}  
		}
	}
	for(i=2;i&lt;=n;i++){
		Q*=P[i];
	}
	return Q;
}

//输出结果
console.log(findQ(20));		
		</code></pre>
	</div>
</body>
</html>